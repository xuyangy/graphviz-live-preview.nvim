<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Graphviz Live Preview</title>
  <style>
    html, body { height: 100%; margin: 0; padding: 0; }
    #graphviz-container { width: 100vw; height: 100vh; }
    .edge-highlight path { stroke: #f00 !important; stroke-width: 3 !important; }
  </style>
</head>
<body>
  <div style="position:fixed;top:10px;left:10px;z-index:10;background:#fff;padding:8px;border-radius:4px;box-shadow:0 2px 8px #0002;">
    <input id="search-box" type="text" placeholder="Search node..." style="width:140px;">
    <button id="export-svg">Export SVG</button>
    <button id="export-dot">Export Dot</button>
  </div>
  <div id="graphviz-container" style="margin-top:50px;"></div>

  <!-- d3 + d3-graphviz + wasm from CDN -->
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://unpkg.com/d3-graphviz@5.0.2/build/d3-graphviz.min.js"></script>
  <script src="https://unpkg.com/@hpcc-js/wasm@2.19.0/dist/index.min.js"></script>

  <script>
    (function () {
      const containerSelector = '#graphviz-container';
      let currentDotSource = '';

      async function loadAndRenderDot() {
        try {
          const res = await fetch('/dot');
          const dot = await res.text();
          currentDotSource = dot || '';
          if (!dot || !dot.trim()) {
            console.warn('graphviz-live-preview: /dot returned empty content');
            return;
          }

          // Use d3-graphviz via d3.select(...).graphviz()
          d3.select(containerSelector)
            .graphviz()
            .renderDot(dot);
        } catch (e) {
          console.error('graphviz-live-preview: failed to load /dot', e);
        }
      }

      function highlightNode(nodeId) {
        const svg = document.querySelector(containerSelector + ' svg');
        if (!svg) return;
        svg.querySelectorAll('.node').forEach(function (node) {
          node.classList.remove('node-highlight');
          const titleElem = node.querySelector('title');
          const title = titleElem && titleElem.textContent;
          if (title && nodeId && title.indexOf(nodeId) !== -1) {
            node.classList.add('node-highlight');
          }
        });
      }

      function downloadFile(filename, content, mime) {
        const blob = new Blob([content], { type: mime });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }

      document.addEventListener('DOMContentLoaded', function () {
        // Load and render the current dot source
        loadAndRenderDot();

        // Search
        const searchBox = document.getElementById('search-box');
        if (searchBox) {
          searchBox.addEventListener('input', function (e) {
            const query = e.target.value.trim();
            highlightNode(query);
          });
        }

        // Export SVG
        const exportSvgBtn = document.getElementById('export-svg');
        if (exportSvgBtn) {
          exportSvgBtn.addEventListener('click', function () {
            const svg = document.querySelector(containerSelector + ' svg');
            if (!svg) return;
            const serializer = new XMLSerializer();
            const svgStr = serializer.serializeToString(svg);
            downloadFile('graph.svg', svgStr, 'image/svg+xml');
          });
        }

        // Export Dot
        const exportDotBtn = document.getElementById('export-dot');
        if (exportDotBtn) {
          exportDotBtn.addEventListener('click', function () {
            downloadFile('graph.dot', currentDotSource, 'text/plain');
          });
        }

        // Highlight style for nodes
        const style = document.createElement('style');
        style.textContent = '.node.node-highlight ellipse, .node.node-highlight polygon, .node.node-highlight path { stroke: #00f !important; stroke-width: 3 !important; }';
        document.head.appendChild(style);
      });
    })();
  </script>
</body>
</html>
